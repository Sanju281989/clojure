{"version":3,"sources":["demo/util.cljs"],"mappings":";;AAcA,iCAAA,jCAAMA,0EAAiBC;AAAvB,AACE,OAACC,qCACC;AAAA,OACM,AAACC,+CAAUF,tDACX,qEAAO,WAAKG;AAAL,AAAA,oBAQgB,AAACC,gCAAqB,WAAKE;AAAL,AAAA,0FAAA,AAAAD,gBAAcL,UAASM","names":["demo.util/lazy-component*","loadable","js/module$node_modules$react$index.lazy","shadow.lazy.load","root-el","reagent.core/reactify-component","cljs.core/deref","props"],"sourcesContent":["(ns demo.util\n  (:require-macros [demo.util])\n  (:require\n    [\"react\" :as react]\n    [reagent.core :as r]\n    [shadow.lazy :as lazy]))\n\n;; the lazy-component macro will emit a simple\n\n;; (demo.util/lazy-component* (shadow.lazy/loadable some.qualified/symbol))\n\n;; you don't actually need this wrapper macro, I just wanted the code to be extra\n;; short for demo purposes.\n\n(defn lazy-component* [loadable]\n  (react/lazy\n    (fn []\n      (-> (lazy/load loadable)\n          (.then (fn [root-el]\n                   ;; React.lazy expects to load a ES6 module with a React Component as default export\n\n                   ;; this would be more correct in production settings\n                   ;; #js {:default (r/reactify-component root-el)}\n\n                   ;; we need wrap the loaded component one extra level so live-reload actually works\n                   ;; since React will keep a reference to the initially loaded fn and won't update it\n                   #js {:default (r/reactify-component (fn [props] [@loadable props]))}\n                   ))))))\n\n"]}