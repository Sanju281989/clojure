["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/crypto-js/cipher-core.js"],"~:js","shadow$provide.module$node_modules$crypto_js$cipher_core=function(global,require,module,exports){(function(root,factory,undef){\"object\"===typeof exports?module.exports=exports=factory(require(\"module$node_modules$crypto_js$core\"),require(\"module$node_modules$crypto_js$evpkdf\")):\"function\"===typeof define&&define.amd?define([\"./core\",\"./evpkdf\"],factory):factory(root.CryptoJS)})(this,function(CryptoJS){CryptoJS.lib.Cipher||function(undefined){var C_lib=CryptoJS.lib,Base=C_lib.Base,WordArray=C_lib.WordArray,\nBufferedBlockAlgorithm=C_lib.BufferedBlockAlgorithm,Base64=CryptoJS.enc.Base64,EvpKDF=CryptoJS.algo.EvpKDF,Cipher=C_lib.Cipher=BufferedBlockAlgorithm.extend({cfg:Base.extend(),createEncryptor:function(key,cfg){return this.create(this._ENC_XFORM_MODE,key,cfg)},createDecryptor:function(key,cfg){return this.create(this._DEC_XFORM_MODE,key,cfg)},init:function(xformMode,key,cfg){this.cfg=this.cfg.extend(cfg);this._xformMode=xformMode;this._key=key;this.reset()},reset:function(){BufferedBlockAlgorithm.reset.call(this);\nthis._doReset()},process:function(dataUpdate){this._append(dataUpdate);return this._process()},finalize:function(dataUpdate){dataUpdate&&this._append(dataUpdate);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){return function(cipher){return{encrypt:function(message,key,cfg){return(\"string\"==typeof key?PasswordBasedCipher:SerializableCipher).encrypt(cipher,message,key,cfg)},decrypt:function(ciphertext,key,cfg){return(\"string\"==typeof key?PasswordBasedCipher:\nSerializableCipher).decrypt(cipher,ciphertext,key,cfg)}}}}()});C_lib.StreamCipher=Cipher.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var C_mode=CryptoJS.mode={},BlockCipherMode=C_lib.BlockCipherMode=Base.extend({createEncryptor:function(cipher,iv){return this.Encryptor.create(cipher,iv)},createDecryptor:function(cipher,iv){return this.Decryptor.create(cipher,iv)},init:function(cipher,iv){this._cipher=cipher;this._iv=iv}});C_mode=C_mode.CBC=function(){function xorBlock(words,\noffset,blockSize){var block;(block=this._iv)?this._iv=undefined:block=this._prevBlock;for(var i=0;i<blockSize;i++)words[offset+i]^=block[i]}var CBC=BlockCipherMode.extend();CBC.Encryptor=CBC.extend({processBlock:function(words,offset){var cipher=this._cipher,blockSize=cipher.blockSize;xorBlock.call(this,words,offset,blockSize);cipher.encryptBlock(words,offset);this._prevBlock=words.slice(offset,offset+blockSize)}});CBC.Decryptor=CBC.extend({processBlock:function(words,offset){var cipher=this._cipher,\nblockSize=cipher.blockSize,thisBlock=words.slice(offset,offset+blockSize);cipher.decryptBlock(words,offset);xorBlock.call(this,words,offset,blockSize);this._prevBlock=thisBlock}});return CBC}();var Pkcs7=(CryptoJS.pad={}).Pkcs7={pad:function(data,blockSize){blockSize*=4;blockSize-=data.sigBytes%blockSize;for(var paddingWord=blockSize<<24|blockSize<<16|blockSize<<8|blockSize,paddingWords=[],i=0;i<blockSize;i+=4)paddingWords.push(paddingWord);blockSize=WordArray.create(paddingWords,blockSize);data.concat(blockSize)},\nunpad:function(data){data.sigBytes-=data.words[data.sigBytes-1>>>2]&255}};C_lib.BlockCipher=Cipher.extend({cfg:Cipher.cfg.extend({mode:C_mode,padding:Pkcs7}),reset:function(){Cipher.reset.call(this);var modeCreator=this.cfg;var iv=modeCreator.iv,mode=modeCreator.mode;this._xformMode==this._ENC_XFORM_MODE?modeCreator=mode.createEncryptor:(modeCreator=mode.createDecryptor,this._minBufferSize=1);this._mode&&this._mode.__creator==modeCreator?this._mode.init(this,iv&&iv.words):(this._mode=modeCreator.call(mode,\nthis,iv&&iv.words),this._mode.__creator=modeCreator)},_doProcessBlock:function(words,offset){this._mode.processBlock(words,offset)},_doFinalize:function(){var padding=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){padding.pad(this._data,this.blockSize);var finalProcessedBlocks=this._process(!0)}else finalProcessedBlocks=this._process(!0),padding.unpad(finalProcessedBlocks);return finalProcessedBlocks},blockSize:4});var CipherParams=C_lib.CipherParams=Base.extend({init:function(cipherParams){this.mixIn(cipherParams)},\ntoString:function(formatter){return(formatter||this.formatter).stringify(this)}});C_mode=(CryptoJS.format={}).OpenSSL={stringify:function(cipherParams){var ciphertext=cipherParams.ciphertext;cipherParams=cipherParams.salt;return(cipherParams?WordArray.create([1398893684,1701076831]).concat(cipherParams).concat(ciphertext):ciphertext).toString(Base64)},parse:function(openSSLStr){openSSLStr=Base64.parse(openSSLStr);var ciphertextWords=openSSLStr.words;if(1398893684==ciphertextWords[0]&&1701076831==\nciphertextWords[1]){var salt=WordArray.create(ciphertextWords.slice(2,4));ciphertextWords.splice(0,4);openSSLStr.sigBytes-=16}return CipherParams.create({ciphertext:openSSLStr,salt})}};var SerializableCipher=C_lib.SerializableCipher=Base.extend({cfg:Base.extend({format:C_mode}),encrypt:function(cipher,message,key,cfg){cfg=this.cfg.extend(cfg);var encryptor=cipher.createEncryptor(key,cfg);message=encryptor.finalize(message);encryptor=encryptor.cfg;return CipherParams.create({ciphertext:message,key,\niv:encryptor.iv,algorithm:cipher,mode:encryptor.mode,padding:encryptor.padding,blockSize:cipher.blockSize,formatter:cfg.format})},decrypt:function(cipher,ciphertext,key,cfg){cfg=this.cfg.extend(cfg);ciphertext=this._parse(ciphertext,cfg.format);return cipher.createDecryptor(key,cfg).finalize(ciphertext.ciphertext)},_parse:function(ciphertext,format){return\"string\"==typeof ciphertext?format.parse(ciphertext,this):ciphertext}});Base=(CryptoJS.kdf={}).OpenSSL={execute:function(password,keySize,ivSize,\nsalt){salt||(salt=WordArray.random(8));password=EvpKDF.create({keySize:keySize+ivSize}).compute(password,salt);ivSize=WordArray.create(password.words.slice(keySize),4*ivSize);password.sigBytes=4*keySize;return CipherParams.create({key:password,iv:ivSize,salt})}};var PasswordBasedCipher=C_lib.PasswordBasedCipher=SerializableCipher.extend({cfg:SerializableCipher.cfg.extend({kdf:Base}),encrypt:function(cipher,message,password,cfg){cfg=this.cfg.extend(cfg);password=cfg.kdf.execute(password,cipher.keySize,\ncipher.ivSize);cfg.iv=password.iv;cipher=SerializableCipher.encrypt.call(this,cipher,message,password.key,cfg);cipher.mixIn(password);return cipher},decrypt:function(cipher,ciphertext,password,cfg){cfg=this.cfg.extend(cfg);ciphertext=this._parse(ciphertext,cfg.format);password=cfg.kdf.execute(password,cipher.keySize,cipher.ivSize,ciphertext.salt);cfg.iv=password.iv;return SerializableCipher.decrypt.call(this,cipher,ciphertext,password.key,cfg)}})}()})}","~:source","shadow$provide[\"module$node_modules$crypto_js$cipher_core\"] = function(global,require,module,exports) {\n;(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./evpkdf\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./evpkdf\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher core components.\n\t */\n\tCryptoJS.lib.Cipher || (function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var Base64 = C_enc.Base64;\n\t    var C_algo = C.algo;\n\t    var EvpKDF = C_algo.EvpKDF;\n\n\t    /**\n\t     * Abstract base cipher template.\n\t     *\n\t     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n\t     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n\t     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n\t     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n\t     */\n\t    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {WordArray} iv The IV to use for this operation.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Creates this cipher in encryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createEncryptor: function (key, cfg) {\n\t            return this.create(this._ENC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Creates this cipher in decryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createDecryptor: function (key, cfg) {\n\t            return this.create(this._DEC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created cipher.\n\t         *\n\t         * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n\t         */\n\t        init: function (xformMode, key, cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Store transform mode and key\n\t            this._xformMode = xformMode;\n\t            this._key = key;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this cipher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     cipher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-cipher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Adds data to be encrypted or decrypted.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.process('data');\n\t         *     var encrypted = cipher.process(wordArray);\n\t         */\n\t        process: function (dataUpdate) {\n\t            // Append\n\t            this._append(dataUpdate);\n\n\t            // Process available blocks\n\t            return this._process();\n\t        },\n\n\t        /**\n\t         * Finalizes the encryption or decryption process.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after final processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.finalize();\n\t         *     var encrypted = cipher.finalize('data');\n\t         *     var encrypted = cipher.finalize(wordArray);\n\t         */\n\t        finalize: function (dataUpdate) {\n\t            // Final data update\n\t            if (dataUpdate) {\n\t                this._append(dataUpdate);\n\t            }\n\n\t            // Perform concrete-cipher logic\n\t            var finalProcessedData = this._doFinalize();\n\n\t            return finalProcessedData;\n\t        },\n\n\t        keySize: 128/32,\n\n\t        ivSize: 128/32,\n\n\t        _ENC_XFORM_MODE: 1,\n\n\t        _DEC_XFORM_MODE: 2,\n\n\t        /**\n\t         * Creates shortcut functions to a cipher's object interface.\n\t         *\n\t         * @param {Cipher} cipher The cipher to create a helper for.\n\t         *\n\t         * @return {Object} An object with encrypt and decrypt shortcut functions.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n\t         */\n\t        _createHelper: (function () {\n\t            function selectCipherStrategy(key) {\n\t                if (typeof key == 'string') {\n\t                    return PasswordBasedCipher;\n\t                } else {\n\t                    return SerializableCipher;\n\t                }\n\t            }\n\n\t            return function (cipher) {\n\t                return {\n\t                    encrypt: function (message, key, cfg) {\n\t                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);\n\t                    },\n\n\t                    decrypt: function (ciphertext, key, cfg) {\n\t                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);\n\t                    }\n\t                };\n\t            };\n\t        }())\n\t    });\n\n\t    /**\n\t     * Abstract base stream cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n\t     */\n\t    var StreamCipher = C_lib.StreamCipher = Cipher.extend({\n\t        _doFinalize: function () {\n\t            // Process partial blocks\n\t            var finalProcessedBlocks = this._process(!!'flush');\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 1\n\t    });\n\n\t    /**\n\t     * Mode namespace.\n\t     */\n\t    var C_mode = C.mode = {};\n\n\t    /**\n\t     * Abstract base block cipher mode template.\n\t     */\n\t    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({\n\t        /**\n\t         * Creates this mode for encryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n\t         */\n\t        createEncryptor: function (cipher, iv) {\n\t            return this.Encryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Creates this mode for decryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n\t         */\n\t        createDecryptor: function (cipher, iv) {\n\t            return this.Decryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created mode.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n\t         */\n\t        init: function (cipher, iv) {\n\t            this._cipher = cipher;\n\t            this._iv = iv;\n\t        }\n\t    });\n\n\t    /**\n\t     * Cipher Block Chaining mode.\n\t     */\n\t    var CBC = C_mode.CBC = (function () {\n\t        /**\n\t         * Abstract base CBC mode.\n\t         */\n\t        var CBC = BlockCipherMode.extend();\n\n\t        /**\n\t         * CBC encryptor.\n\t         */\n\t        CBC.Encryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // XOR and encrypt\n\t                xorBlock.call(this, words, offset, blockSize);\n\t                cipher.encryptBlock(words, offset);\n\n\t                // Remember this block to use with next block\n\t                this._prevBlock = words.slice(offset, offset + blockSize);\n\t            }\n\t        });\n\n\t        /**\n\t         * CBC decryptor.\n\t         */\n\t        CBC.Decryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // Remember this block to use with next block\n\t                var thisBlock = words.slice(offset, offset + blockSize);\n\n\t                // Decrypt and XOR\n\t                cipher.decryptBlock(words, offset);\n\t                xorBlock.call(this, words, offset, blockSize);\n\n\t                // This block becomes the previous block\n\t                this._prevBlock = thisBlock;\n\t            }\n\t        });\n\n\t        function xorBlock(words, offset, blockSize) {\n\t            var block;\n\n\t            // Shortcut\n\t            var iv = this._iv;\n\n\t            // Choose mixing block\n\t            if (iv) {\n\t                block = iv;\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            } else {\n\t                block = this._prevBlock;\n\t            }\n\n\t            // XOR blocks\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= block[i];\n\t            }\n\t        }\n\n\t        return CBC;\n\t    }());\n\n\t    /**\n\t     * Padding namespace.\n\t     */\n\t    var C_pad = C.pad = {};\n\n\t    /**\n\t     * PKCS #5/7 padding strategy.\n\t     */\n\t    var Pkcs7 = C_pad.Pkcs7 = {\n\t        /**\n\t         * Pads data using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to pad.\n\t         * @param {number} blockSize The multiple that the data should be padded to.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n\t         */\n\t        pad: function (data, blockSize) {\n\t            // Shortcut\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count padding bytes\n\t            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t            // Create padding word\n\t            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n\n\t            // Create padding\n\t            var paddingWords = [];\n\t            for (var i = 0; i < nPaddingBytes; i += 4) {\n\t                paddingWords.push(paddingWord);\n\t            }\n\t            var padding = WordArray.create(paddingWords, nPaddingBytes);\n\n\t            // Add padding\n\t            data.concat(padding);\n\t        },\n\n\t        /**\n\t         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to unpad.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n\t         */\n\t        unpad: function (data) {\n\t            // Get number of padding bytes from last byte\n\t            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t            // Remove padding\n\t            data.sigBytes -= nPaddingBytes;\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract base block cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n\t     */\n\t    var BlockCipher = C_lib.BlockCipher = Cipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Mode} mode The block mode to use. Default: CBC\n\t         * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n\t         */\n\t        cfg: Cipher.cfg.extend({\n\t            mode: CBC,\n\t            padding: Pkcs7\n\t        }),\n\n\t        reset: function () {\n\t            var modeCreator;\n\n\t            // Reset cipher\n\t            Cipher.reset.call(this);\n\n\t            // Shortcuts\n\t            var cfg = this.cfg;\n\t            var iv = cfg.iv;\n\t            var mode = cfg.mode;\n\n\t            // Reset block mode\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                modeCreator = mode.createEncryptor;\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                modeCreator = mode.createDecryptor;\n\t                // Keep at least one block in the buffer for unpadding\n\t                this._minBufferSize = 1;\n\t            }\n\n\t            if (this._mode && this._mode.__creator == modeCreator) {\n\t                this._mode.init(this, iv && iv.words);\n\t            } else {\n\t                this._mode = modeCreator.call(mode, this, iv && iv.words);\n\t                this._mode.__creator = modeCreator;\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (words, offset) {\n\t            this._mode.processBlock(words, offset);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var finalProcessedBlocks;\n\n\t            // Shortcut\n\t            var padding = this.cfg.padding;\n\n\t            // Finalize\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                // Pad data\n\t                padding.pad(this._data, this.blockSize);\n\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\n\t                // Unpad data\n\t                padding.unpad(finalProcessedBlocks);\n\t            }\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 128/32\n\t    });\n\n\t    /**\n\t     * A collection of cipher parameters.\n\t     *\n\t     * @property {WordArray} ciphertext The raw ciphertext.\n\t     * @property {WordArray} key The key to this ciphertext.\n\t     * @property {WordArray} iv The IV used in the ciphering operation.\n\t     * @property {WordArray} salt The salt used with a key derivation function.\n\t     * @property {Cipher} algorithm The cipher algorithm.\n\t     * @property {Mode} mode The block mode used in the ciphering operation.\n\t     * @property {Padding} padding The padding scheme used in the ciphering operation.\n\t     * @property {number} blockSize The block size of the cipher.\n\t     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.\n\t     */\n\t    var CipherParams = C_lib.CipherParams = Base.extend({\n\t        /**\n\t         * Initializes a newly created cipher params object.\n\t         *\n\t         * @param {Object} cipherParams An object with any of the possible cipher parameters.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.lib.CipherParams.create({\n\t         *         ciphertext: ciphertextWordArray,\n\t         *         key: keyWordArray,\n\t         *         iv: ivWordArray,\n\t         *         salt: saltWordArray,\n\t         *         algorithm: CryptoJS.algo.AES,\n\t         *         mode: CryptoJS.mode.CBC,\n\t         *         padding: CryptoJS.pad.PKCS7,\n\t         *         blockSize: 4,\n\t         *         formatter: CryptoJS.format.OpenSSL\n\t         *     });\n\t         */\n\t        init: function (cipherParams) {\n\t            this.mixIn(cipherParams);\n\t        },\n\n\t        /**\n\t         * Converts this cipher params object to a string.\n\t         *\n\t         * @param {Format} formatter (Optional) The formatting strategy to use.\n\t         *\n\t         * @return {string} The stringified cipher params.\n\t         *\n\t         * @throws Error If neither the formatter nor the default formatter is set.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = cipherParams + '';\n\t         *     var string = cipherParams.toString();\n\t         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n\t         */\n\t        toString: function (formatter) {\n\t            return (formatter || this.formatter).stringify(this);\n\t        }\n\t    });\n\n\t    /**\n\t     * Format namespace.\n\t     */\n\t    var C_format = C.format = {};\n\n\t    /**\n\t     * OpenSSL formatting strategy.\n\t     */\n\t    var OpenSSLFormatter = C_format.OpenSSL = {\n\t        /**\n\t         * Converts a cipher params object to an OpenSSL-compatible string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The OpenSSL-compatible string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            var wordArray;\n\n\t            // Shortcuts\n\t            var ciphertext = cipherParams.ciphertext;\n\t            var salt = cipherParams.salt;\n\n\t            // Format\n\t            if (salt) {\n\t                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n\t            } else {\n\t                wordArray = ciphertext;\n\t            }\n\n\t            return wordArray.toString(Base64);\n\t        },\n\n\t        /**\n\t         * Converts an OpenSSL-compatible string to a cipher params object.\n\t         *\n\t         * @param {string} openSSLStr The OpenSSL-compatible string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n\t         */\n\t        parse: function (openSSLStr) {\n\t            var salt;\n\n\t            // Parse base64\n\t            var ciphertext = Base64.parse(openSSLStr);\n\n\t            // Shortcut\n\t            var ciphertextWords = ciphertext.words;\n\n\t            // Test for salt\n\t            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {\n\t                // Extract salt\n\t                salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n\t                // Remove salt from ciphertext\n\t                ciphertextWords.splice(0, 4);\n\t                ciphertext.sigBytes -= 16;\n\t            }\n\n\t            return CipherParams.create({ ciphertext: ciphertext, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var SerializableCipher = C_lib.SerializableCipher = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\n\t         */\n\t        cfg: Base.extend({\n\t            format: OpenSSLFormatter\n\t        }),\n\n\t        /**\n\t         * Encrypts a message.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Encrypt\n\t            var encryptor = cipher.createEncryptor(key, cfg);\n\t            var ciphertext = encryptor.finalize(message);\n\n\t            // Shortcut\n\t            var cipherCfg = encryptor.cfg;\n\n\t            // Create and return serializable cipher params\n\t            return CipherParams.create({\n\t                ciphertext: ciphertext,\n\t                key: key,\n\t                iv: cipherCfg.iv,\n\t                algorithm: cipher,\n\t                mode: cipherCfg.mode,\n\t                padding: cipherCfg.padding,\n\t                blockSize: cipher.blockSize,\n\t                formatter: cfg.format\n\t            });\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Decrypt\n\t            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n\t            return plaintext;\n\t        },\n\n\t        /**\n\t         * Converts serialized ciphertext to CipherParams,\n\t         * else assumed CipherParams already and returns ciphertext unchanged.\n\t         *\n\t         * @param {CipherParams|string} ciphertext The ciphertext.\n\t         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n\t         *\n\t         * @return {CipherParams} The unserialized ciphertext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n\t         */\n\t        _parse: function (ciphertext, format) {\n\t            if (typeof ciphertext == 'string') {\n\t                return format.parse(ciphertext, this);\n\t            } else {\n\t                return ciphertext;\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Key derivation function namespace.\n\t     */\n\t    var C_kdf = C.kdf = {};\n\n\t    /**\n\t     * OpenSSL key derivation function.\n\t     */\n\t    var OpenSSLKdf = C_kdf.OpenSSL = {\n\t        /**\n\t         * Derives a key and IV from a password.\n\t         *\n\t         * @param {string} password The password to derive from.\n\t         * @param {number} keySize The size in words of the key to generate.\n\t         * @param {number} ivSize The size in words of the IV to generate.\n\t         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n\t         *\n\t         * @return {CipherParams} A cipher params object with the key, IV, and salt.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n\t         */\n\t        execute: function (password, keySize, ivSize, salt) {\n\t            // Generate random salt\n\t            if (!salt) {\n\t                salt = WordArray.random(64/8);\n\t            }\n\n\t            // Derive key and IV\n\t            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);\n\n\t            // Separate key and IV\n\t            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n\t            key.sigBytes = keySize * 4;\n\n\t            // Return params\n\t            return CipherParams.create({ key: key, iv: iv, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A serializable cipher wrapper that derives the key from a password,\n\t     * and returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\n\t         */\n\t        cfg: SerializableCipher.cfg.extend({\n\t            kdf: OpenSSLKdf\n\t        }),\n\n\t        /**\n\t         * Encrypts a message using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Encrypt\n\t            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);\n\n\t            // Mix in derived params\n\t            ciphertext.mixIn(derivedParams);\n\n\t            return ciphertext;\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Decrypt\n\t            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);\n\n\t            return plaintext;\n\t        }\n\t    });\n\t}());\n\n\n}));\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$crypto_js$core","~$shadow.js","~$module$node_modules$crypto_js$evpkdf"]],"~:properties",["^5",["iv","_key","encrypt","BlockCipherMode","ciphertext","_cipher","keySize","pad","Cipher","BlockCipher","unpad","OpenSSL","cfg","key","process","padding","_xformMode","_createHelper","toString","reset","algorithm","_minBufferSize","mode","SerializableCipher","_prevBlock","_doFinalize","ivSize","processBlock","Encryptor","blockSize","salt","sigBytes","_doProcessBlock","PasswordBasedCipher","stringify","init","Decryptor","decrypt","execute","Pkcs7","formatter","parse","createDecryptor","CipherParams","_parse","CBC","_iv","kdf","_ENC_XFORM_MODE","createEncryptor","StreamCipher","_mode","__creator","format","_DEC_XFORM_MODE","finalize"]],"~:compiled-at",1645079148535,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$crypto_js$cipher_core.js\",\n\"lineCount\":13,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/crypto-js/cipher-core.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$crypto_js$cipher_core\\\"] = function(global,require,module,exports) {\\n;(function (root, factory, undef) {\\n\\tif (typeof exports === \\\"object\\\") {\\n\\t\\t// CommonJS\\n\\t\\tmodule.exports = exports = factory(require(\\\"./core\\\"), require(\\\"./evpkdf\\\"));\\n\\t}\\n\\telse if (typeof define === \\\"function\\\" && define.amd) {\\n\\t\\t// AMD\\n\\t\\tdefine([\\\"./core\\\", \\\"./evpkdf\\\"], factory);\\n\\t}\\n\\telse {\\n\\t\\t// Global (browser)\\n\\t\\tfactory(root.CryptoJS);\\n\\t}\\n}(this, function (CryptoJS) {\\n\\n\\t/**\\n\\t * Cipher core components.\\n\\t */\\n\\tCryptoJS.lib.Cipher || (function (undefined) {\\n\\t    // Shortcuts\\n\\t    var C = CryptoJS;\\n\\t    var C_lib = C.lib;\\n\\t    var Base = C_lib.Base;\\n\\t    var WordArray = C_lib.WordArray;\\n\\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;\\n\\t    var C_enc = C.enc;\\n\\t    var Utf8 = C_enc.Utf8;\\n\\t    var Base64 = C_enc.Base64;\\n\\t    var C_algo = C.algo;\\n\\t    var EvpKDF = C_algo.EvpKDF;\\n\\n\\t    /**\\n\\t     * Abstract base cipher template.\\n\\t     *\\n\\t     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\\n\\t     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\\n\\t     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\\n\\t     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\\n\\t     */\\n\\t    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({\\n\\t        /**\\n\\t         * Configuration options.\\n\\t         *\\n\\t         * @property {WordArray} iv The IV to use for this operation.\\n\\t         */\\n\\t        cfg: Base.extend(),\\n\\n\\t        /**\\n\\t         * Creates this cipher in encryption mode.\\n\\t         *\\n\\t         * @param {WordArray} key The key.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {Cipher} A cipher instance.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\\n\\t         */\\n\\t        createEncryptor: function (key, cfg) {\\n\\t            return this.create(this._ENC_XFORM_MODE, key, cfg);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Creates this cipher in decryption mode.\\n\\t         *\\n\\t         * @param {WordArray} key The key.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {Cipher} A cipher instance.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\\n\\t         */\\n\\t        createDecryptor: function (key, cfg) {\\n\\t            return this.create(this._DEC_XFORM_MODE, key, cfg);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Initializes a newly created cipher.\\n\\t         *\\n\\t         * @param {number} xformMode Either the encryption or decryption transormation mode constant.\\n\\t         * @param {WordArray} key The key.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\\n\\t         */\\n\\t        init: function (xformMode, key, cfg) {\\n\\t            // Apply config defaults\\n\\t            this.cfg = this.cfg.extend(cfg);\\n\\n\\t            // Store transform mode and key\\n\\t            this._xformMode = xformMode;\\n\\t            this._key = key;\\n\\n\\t            // Set initial values\\n\\t            this.reset();\\n\\t        },\\n\\n\\t        /**\\n\\t         * Resets this cipher to its initial state.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     cipher.reset();\\n\\t         */\\n\\t        reset: function () {\\n\\t            // Reset data buffer\\n\\t            BufferedBlockAlgorithm.reset.call(this);\\n\\n\\t            // Perform concrete-cipher logic\\n\\t            this._doReset();\\n\\t        },\\n\\n\\t        /**\\n\\t         * Adds data to be encrypted or decrypted.\\n\\t         *\\n\\t         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\\n\\t         *\\n\\t         * @return {WordArray} The data after processing.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var encrypted = cipher.process('data');\\n\\t         *     var encrypted = cipher.process(wordArray);\\n\\t         */\\n\\t        process: function (dataUpdate) {\\n\\t            // Append\\n\\t            this._append(dataUpdate);\\n\\n\\t            // Process available blocks\\n\\t            return this._process();\\n\\t        },\\n\\n\\t        /**\\n\\t         * Finalizes the encryption or decryption process.\\n\\t         * Note that the finalize operation is effectively a destructive, read-once operation.\\n\\t         *\\n\\t         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\\n\\t         *\\n\\t         * @return {WordArray} The data after final processing.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var encrypted = cipher.finalize();\\n\\t         *     var encrypted = cipher.finalize('data');\\n\\t         *     var encrypted = cipher.finalize(wordArray);\\n\\t         */\\n\\t        finalize: function (dataUpdate) {\\n\\t            // Final data update\\n\\t            if (dataUpdate) {\\n\\t                this._append(dataUpdate);\\n\\t            }\\n\\n\\t            // Perform concrete-cipher logic\\n\\t            var finalProcessedData = this._doFinalize();\\n\\n\\t            return finalProcessedData;\\n\\t        },\\n\\n\\t        keySize: 128/32,\\n\\n\\t        ivSize: 128/32,\\n\\n\\t        _ENC_XFORM_MODE: 1,\\n\\n\\t        _DEC_XFORM_MODE: 2,\\n\\n\\t        /**\\n\\t         * Creates shortcut functions to a cipher's object interface.\\n\\t         *\\n\\t         * @param {Cipher} cipher The cipher to create a helper for.\\n\\t         *\\n\\t         * @return {Object} An object with encrypt and decrypt shortcut functions.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\\n\\t         */\\n\\t        _createHelper: (function () {\\n\\t            function selectCipherStrategy(key) {\\n\\t                if (typeof key == 'string') {\\n\\t                    return PasswordBasedCipher;\\n\\t                } else {\\n\\t                    return SerializableCipher;\\n\\t                }\\n\\t            }\\n\\n\\t            return function (cipher) {\\n\\t                return {\\n\\t                    encrypt: function (message, key, cfg) {\\n\\t                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);\\n\\t                    },\\n\\n\\t                    decrypt: function (ciphertext, key, cfg) {\\n\\t                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);\\n\\t                    }\\n\\t                };\\n\\t            };\\n\\t        }())\\n\\t    });\\n\\n\\t    /**\\n\\t     * Abstract base stream cipher template.\\n\\t     *\\n\\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\\n\\t     */\\n\\t    var StreamCipher = C_lib.StreamCipher = Cipher.extend({\\n\\t        _doFinalize: function () {\\n\\t            // Process partial blocks\\n\\t            var finalProcessedBlocks = this._process(!!'flush');\\n\\n\\t            return finalProcessedBlocks;\\n\\t        },\\n\\n\\t        blockSize: 1\\n\\t    });\\n\\n\\t    /**\\n\\t     * Mode namespace.\\n\\t     */\\n\\t    var C_mode = C.mode = {};\\n\\n\\t    /**\\n\\t     * Abstract base block cipher mode template.\\n\\t     */\\n\\t    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({\\n\\t        /**\\n\\t         * Creates this mode for encryption.\\n\\t         *\\n\\t         * @param {Cipher} cipher A block cipher instance.\\n\\t         * @param {Array} iv The IV words.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\\n\\t         */\\n\\t        createEncryptor: function (cipher, iv) {\\n\\t            return this.Encryptor.create(cipher, iv);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Creates this mode for decryption.\\n\\t         *\\n\\t         * @param {Cipher} cipher A block cipher instance.\\n\\t         * @param {Array} iv The IV words.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\\n\\t         */\\n\\t        createDecryptor: function (cipher, iv) {\\n\\t            return this.Decryptor.create(cipher, iv);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Initializes a newly created mode.\\n\\t         *\\n\\t         * @param {Cipher} cipher A block cipher instance.\\n\\t         * @param {Array} iv The IV words.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\\n\\t         */\\n\\t        init: function (cipher, iv) {\\n\\t            this._cipher = cipher;\\n\\t            this._iv = iv;\\n\\t        }\\n\\t    });\\n\\n\\t    /**\\n\\t     * Cipher Block Chaining mode.\\n\\t     */\\n\\t    var CBC = C_mode.CBC = (function () {\\n\\t        /**\\n\\t         * Abstract base CBC mode.\\n\\t         */\\n\\t        var CBC = BlockCipherMode.extend();\\n\\n\\t        /**\\n\\t         * CBC encryptor.\\n\\t         */\\n\\t        CBC.Encryptor = CBC.extend({\\n\\t            /**\\n\\t             * Processes the data block at offset.\\n\\t             *\\n\\t             * @param {Array} words The data words to operate on.\\n\\t             * @param {number} offset The offset where the block starts.\\n\\t             *\\n\\t             * @example\\n\\t             *\\n\\t             *     mode.processBlock(data.words, offset);\\n\\t             */\\n\\t            processBlock: function (words, offset) {\\n\\t                // Shortcuts\\n\\t                var cipher = this._cipher;\\n\\t                var blockSize = cipher.blockSize;\\n\\n\\t                // XOR and encrypt\\n\\t                xorBlock.call(this, words, offset, blockSize);\\n\\t                cipher.encryptBlock(words, offset);\\n\\n\\t                // Remember this block to use with next block\\n\\t                this._prevBlock = words.slice(offset, offset + blockSize);\\n\\t            }\\n\\t        });\\n\\n\\t        /**\\n\\t         * CBC decryptor.\\n\\t         */\\n\\t        CBC.Decryptor = CBC.extend({\\n\\t            /**\\n\\t             * Processes the data block at offset.\\n\\t             *\\n\\t             * @param {Array} words The data words to operate on.\\n\\t             * @param {number} offset The offset where the block starts.\\n\\t             *\\n\\t             * @example\\n\\t             *\\n\\t             *     mode.processBlock(data.words, offset);\\n\\t             */\\n\\t            processBlock: function (words, offset) {\\n\\t                // Shortcuts\\n\\t                var cipher = this._cipher;\\n\\t                var blockSize = cipher.blockSize;\\n\\n\\t                // Remember this block to use with next block\\n\\t                var thisBlock = words.slice(offset, offset + blockSize);\\n\\n\\t                // Decrypt and XOR\\n\\t                cipher.decryptBlock(words, offset);\\n\\t                xorBlock.call(this, words, offset, blockSize);\\n\\n\\t                // This block becomes the previous block\\n\\t                this._prevBlock = thisBlock;\\n\\t            }\\n\\t        });\\n\\n\\t        function xorBlock(words, offset, blockSize) {\\n\\t            var block;\\n\\n\\t            // Shortcut\\n\\t            var iv = this._iv;\\n\\n\\t            // Choose mixing block\\n\\t            if (iv) {\\n\\t                block = iv;\\n\\n\\t                // Remove IV for subsequent blocks\\n\\t                this._iv = undefined;\\n\\t            } else {\\n\\t                block = this._prevBlock;\\n\\t            }\\n\\n\\t            // XOR blocks\\n\\t            for (var i = 0; i < blockSize; i++) {\\n\\t                words[offset + i] ^= block[i];\\n\\t            }\\n\\t        }\\n\\n\\t        return CBC;\\n\\t    }());\\n\\n\\t    /**\\n\\t     * Padding namespace.\\n\\t     */\\n\\t    var C_pad = C.pad = {};\\n\\n\\t    /**\\n\\t     * PKCS #5/7 padding strategy.\\n\\t     */\\n\\t    var Pkcs7 = C_pad.Pkcs7 = {\\n\\t        /**\\n\\t         * Pads data using the algorithm defined in PKCS #5/7.\\n\\t         *\\n\\t         * @param {WordArray} data The data to pad.\\n\\t         * @param {number} blockSize The multiple that the data should be padded to.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\\n\\t         */\\n\\t        pad: function (data, blockSize) {\\n\\t            // Shortcut\\n\\t            var blockSizeBytes = blockSize * 4;\\n\\n\\t            // Count padding bytes\\n\\t            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\\n\\n\\t            // Create padding word\\n\\t            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\\n\\n\\t            // Create padding\\n\\t            var paddingWords = [];\\n\\t            for (var i = 0; i < nPaddingBytes; i += 4) {\\n\\t                paddingWords.push(paddingWord);\\n\\t            }\\n\\t            var padding = WordArray.create(paddingWords, nPaddingBytes);\\n\\n\\t            // Add padding\\n\\t            data.concat(padding);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\\n\\t         *\\n\\t         * @param {WordArray} data The data to unpad.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     CryptoJS.pad.Pkcs7.unpad(wordArray);\\n\\t         */\\n\\t        unpad: function (data) {\\n\\t            // Get number of padding bytes from last byte\\n\\t            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\\n\\n\\t            // Remove padding\\n\\t            data.sigBytes -= nPaddingBytes;\\n\\t        }\\n\\t    };\\n\\n\\t    /**\\n\\t     * Abstract base block cipher template.\\n\\t     *\\n\\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\\n\\t     */\\n\\t    var BlockCipher = C_lib.BlockCipher = Cipher.extend({\\n\\t        /**\\n\\t         * Configuration options.\\n\\t         *\\n\\t         * @property {Mode} mode The block mode to use. Default: CBC\\n\\t         * @property {Padding} padding The padding strategy to use. Default: Pkcs7\\n\\t         */\\n\\t        cfg: Cipher.cfg.extend({\\n\\t            mode: CBC,\\n\\t            padding: Pkcs7\\n\\t        }),\\n\\n\\t        reset: function () {\\n\\t            var modeCreator;\\n\\n\\t            // Reset cipher\\n\\t            Cipher.reset.call(this);\\n\\n\\t            // Shortcuts\\n\\t            var cfg = this.cfg;\\n\\t            var iv = cfg.iv;\\n\\t            var mode = cfg.mode;\\n\\n\\t            // Reset block mode\\n\\t            if (this._xformMode == this._ENC_XFORM_MODE) {\\n\\t                modeCreator = mode.createEncryptor;\\n\\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\\n\\t                modeCreator = mode.createDecryptor;\\n\\t                // Keep at least one block in the buffer for unpadding\\n\\t                this._minBufferSize = 1;\\n\\t            }\\n\\n\\t            if (this._mode && this._mode.__creator == modeCreator) {\\n\\t                this._mode.init(this, iv && iv.words);\\n\\t            } else {\\n\\t                this._mode = modeCreator.call(mode, this, iv && iv.words);\\n\\t                this._mode.__creator = modeCreator;\\n\\t            }\\n\\t        },\\n\\n\\t        _doProcessBlock: function (words, offset) {\\n\\t            this._mode.processBlock(words, offset);\\n\\t        },\\n\\n\\t        _doFinalize: function () {\\n\\t            var finalProcessedBlocks;\\n\\n\\t            // Shortcut\\n\\t            var padding = this.cfg.padding;\\n\\n\\t            // Finalize\\n\\t            if (this._xformMode == this._ENC_XFORM_MODE) {\\n\\t                // Pad data\\n\\t                padding.pad(this._data, this.blockSize);\\n\\n\\t                // Process final blocks\\n\\t                finalProcessedBlocks = this._process(!!'flush');\\n\\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\\n\\t                // Process final blocks\\n\\t                finalProcessedBlocks = this._process(!!'flush');\\n\\n\\t                // Unpad data\\n\\t                padding.unpad(finalProcessedBlocks);\\n\\t            }\\n\\n\\t            return finalProcessedBlocks;\\n\\t        },\\n\\n\\t        blockSize: 128/32\\n\\t    });\\n\\n\\t    /**\\n\\t     * A collection of cipher parameters.\\n\\t     *\\n\\t     * @property {WordArray} ciphertext The raw ciphertext.\\n\\t     * @property {WordArray} key The key to this ciphertext.\\n\\t     * @property {WordArray} iv The IV used in the ciphering operation.\\n\\t     * @property {WordArray} salt The salt used with a key derivation function.\\n\\t     * @property {Cipher} algorithm The cipher algorithm.\\n\\t     * @property {Mode} mode The block mode used in the ciphering operation.\\n\\t     * @property {Padding} padding The padding scheme used in the ciphering operation.\\n\\t     * @property {number} blockSize The block size of the cipher.\\n\\t     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.\\n\\t     */\\n\\t    var CipherParams = C_lib.CipherParams = Base.extend({\\n\\t        /**\\n\\t         * Initializes a newly created cipher params object.\\n\\t         *\\n\\t         * @param {Object} cipherParams An object with any of the possible cipher parameters.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var cipherParams = CryptoJS.lib.CipherParams.create({\\n\\t         *         ciphertext: ciphertextWordArray,\\n\\t         *         key: keyWordArray,\\n\\t         *         iv: ivWordArray,\\n\\t         *         salt: saltWordArray,\\n\\t         *         algorithm: CryptoJS.algo.AES,\\n\\t         *         mode: CryptoJS.mode.CBC,\\n\\t         *         padding: CryptoJS.pad.PKCS7,\\n\\t         *         blockSize: 4,\\n\\t         *         formatter: CryptoJS.format.OpenSSL\\n\\t         *     });\\n\\t         */\\n\\t        init: function (cipherParams) {\\n\\t            this.mixIn(cipherParams);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Converts this cipher params object to a string.\\n\\t         *\\n\\t         * @param {Format} formatter (Optional) The formatting strategy to use.\\n\\t         *\\n\\t         * @return {string} The stringified cipher params.\\n\\t         *\\n\\t         * @throws Error If neither the formatter nor the default formatter is set.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var string = cipherParams + '';\\n\\t         *     var string = cipherParams.toString();\\n\\t         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\\n\\t         */\\n\\t        toString: function (formatter) {\\n\\t            return (formatter || this.formatter).stringify(this);\\n\\t        }\\n\\t    });\\n\\n\\t    /**\\n\\t     * Format namespace.\\n\\t     */\\n\\t    var C_format = C.format = {};\\n\\n\\t    /**\\n\\t     * OpenSSL formatting strategy.\\n\\t     */\\n\\t    var OpenSSLFormatter = C_format.OpenSSL = {\\n\\t        /**\\n\\t         * Converts a cipher params object to an OpenSSL-compatible string.\\n\\t         *\\n\\t         * @param {CipherParams} cipherParams The cipher params object.\\n\\t         *\\n\\t         * @return {string} The OpenSSL-compatible string.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\\n\\t         */\\n\\t        stringify: function (cipherParams) {\\n\\t            var wordArray;\\n\\n\\t            // Shortcuts\\n\\t            var ciphertext = cipherParams.ciphertext;\\n\\t            var salt = cipherParams.salt;\\n\\n\\t            // Format\\n\\t            if (salt) {\\n\\t                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\\n\\t            } else {\\n\\t                wordArray = ciphertext;\\n\\t            }\\n\\n\\t            return wordArray.toString(Base64);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Converts an OpenSSL-compatible string to a cipher params object.\\n\\t         *\\n\\t         * @param {string} openSSLStr The OpenSSL-compatible string.\\n\\t         *\\n\\t         * @return {CipherParams} The cipher params object.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\\n\\t         */\\n\\t        parse: function (openSSLStr) {\\n\\t            var salt;\\n\\n\\t            // Parse base64\\n\\t            var ciphertext = Base64.parse(openSSLStr);\\n\\n\\t            // Shortcut\\n\\t            var ciphertextWords = ciphertext.words;\\n\\n\\t            // Test for salt\\n\\t            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {\\n\\t                // Extract salt\\n\\t                salt = WordArray.create(ciphertextWords.slice(2, 4));\\n\\n\\t                // Remove salt from ciphertext\\n\\t                ciphertextWords.splice(0, 4);\\n\\t                ciphertext.sigBytes -= 16;\\n\\t            }\\n\\n\\t            return CipherParams.create({ ciphertext: ciphertext, salt: salt });\\n\\t        }\\n\\t    };\\n\\n\\t    /**\\n\\t     * A cipher wrapper that returns ciphertext as a serializable cipher params object.\\n\\t     */\\n\\t    var SerializableCipher = C_lib.SerializableCipher = Base.extend({\\n\\t        /**\\n\\t         * Configuration options.\\n\\t         *\\n\\t         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\\n\\t         */\\n\\t        cfg: Base.extend({\\n\\t            format: OpenSSLFormatter\\n\\t        }),\\n\\n\\t        /**\\n\\t         * Encrypts a message.\\n\\t         *\\n\\t         * @param {Cipher} cipher The cipher algorithm to use.\\n\\t         * @param {WordArray|string} message The message to encrypt.\\n\\t         * @param {WordArray} key The key.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {CipherParams} A cipher params object.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\\n\\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\\n\\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\\n\\t         */\\n\\t        encrypt: function (cipher, message, key, cfg) {\\n\\t            // Apply config defaults\\n\\t            cfg = this.cfg.extend(cfg);\\n\\n\\t            // Encrypt\\n\\t            var encryptor = cipher.createEncryptor(key, cfg);\\n\\t            var ciphertext = encryptor.finalize(message);\\n\\n\\t            // Shortcut\\n\\t            var cipherCfg = encryptor.cfg;\\n\\n\\t            // Create and return serializable cipher params\\n\\t            return CipherParams.create({\\n\\t                ciphertext: ciphertext,\\n\\t                key: key,\\n\\t                iv: cipherCfg.iv,\\n\\t                algorithm: cipher,\\n\\t                mode: cipherCfg.mode,\\n\\t                padding: cipherCfg.padding,\\n\\t                blockSize: cipher.blockSize,\\n\\t                formatter: cfg.format\\n\\t            });\\n\\t        },\\n\\n\\t        /**\\n\\t         * Decrypts serialized ciphertext.\\n\\t         *\\n\\t         * @param {Cipher} cipher The cipher algorithm to use.\\n\\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\\n\\t         * @param {WordArray} key The key.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {WordArray} The plaintext.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\\n\\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\\n\\t         */\\n\\t        decrypt: function (cipher, ciphertext, key, cfg) {\\n\\t            // Apply config defaults\\n\\t            cfg = this.cfg.extend(cfg);\\n\\n\\t            // Convert string to CipherParams\\n\\t            ciphertext = this._parse(ciphertext, cfg.format);\\n\\n\\t            // Decrypt\\n\\t            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\\n\\n\\t            return plaintext;\\n\\t        },\\n\\n\\t        /**\\n\\t         * Converts serialized ciphertext to CipherParams,\\n\\t         * else assumed CipherParams already and returns ciphertext unchanged.\\n\\t         *\\n\\t         * @param {CipherParams|string} ciphertext The ciphertext.\\n\\t         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\\n\\t         *\\n\\t         * @return {CipherParams} The unserialized ciphertext.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\\n\\t         */\\n\\t        _parse: function (ciphertext, format) {\\n\\t            if (typeof ciphertext == 'string') {\\n\\t                return format.parse(ciphertext, this);\\n\\t            } else {\\n\\t                return ciphertext;\\n\\t            }\\n\\t        }\\n\\t    });\\n\\n\\t    /**\\n\\t     * Key derivation function namespace.\\n\\t     */\\n\\t    var C_kdf = C.kdf = {};\\n\\n\\t    /**\\n\\t     * OpenSSL key derivation function.\\n\\t     */\\n\\t    var OpenSSLKdf = C_kdf.OpenSSL = {\\n\\t        /**\\n\\t         * Derives a key and IV from a password.\\n\\t         *\\n\\t         * @param {string} password The password to derive from.\\n\\t         * @param {number} keySize The size in words of the key to generate.\\n\\t         * @param {number} ivSize The size in words of the IV to generate.\\n\\t         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\\n\\t         *\\n\\t         * @return {CipherParams} A cipher params object with the key, IV, and salt.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\\n\\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\\n\\t         */\\n\\t        execute: function (password, keySize, ivSize, salt) {\\n\\t            // Generate random salt\\n\\t            if (!salt) {\\n\\t                salt = WordArray.random(64/8);\\n\\t            }\\n\\n\\t            // Derive key and IV\\n\\t            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);\\n\\n\\t            // Separate key and IV\\n\\t            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\\n\\t            key.sigBytes = keySize * 4;\\n\\n\\t            // Return params\\n\\t            return CipherParams.create({ key: key, iv: iv, salt: salt });\\n\\t        }\\n\\t    };\\n\\n\\t    /**\\n\\t     * A serializable cipher wrapper that derives the key from a password,\\n\\t     * and returns ciphertext as a serializable cipher params object.\\n\\t     */\\n\\t    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({\\n\\t        /**\\n\\t         * Configuration options.\\n\\t         *\\n\\t         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\\n\\t         */\\n\\t        cfg: SerializableCipher.cfg.extend({\\n\\t            kdf: OpenSSLKdf\\n\\t        }),\\n\\n\\t        /**\\n\\t         * Encrypts a message using a password.\\n\\t         *\\n\\t         * @param {Cipher} cipher The cipher algorithm to use.\\n\\t         * @param {WordArray|string} message The message to encrypt.\\n\\t         * @param {string} password The password.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {CipherParams} A cipher params object.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\\n\\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\\n\\t         */\\n\\t        encrypt: function (cipher, message, password, cfg) {\\n\\t            // Apply config defaults\\n\\t            cfg = this.cfg.extend(cfg);\\n\\n\\t            // Derive key and other params\\n\\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\\n\\n\\t            // Add IV to config\\n\\t            cfg.iv = derivedParams.iv;\\n\\n\\t            // Encrypt\\n\\t            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);\\n\\n\\t            // Mix in derived params\\n\\t            ciphertext.mixIn(derivedParams);\\n\\n\\t            return ciphertext;\\n\\t        },\\n\\n\\t        /**\\n\\t         * Decrypts serialized ciphertext using a password.\\n\\t         *\\n\\t         * @param {Cipher} cipher The cipher algorithm to use.\\n\\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\\n\\t         * @param {string} password The password.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {WordArray} The plaintext.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\\n\\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\\n\\t         */\\n\\t        decrypt: function (cipher, ciphertext, password, cfg) {\\n\\t            // Apply config defaults\\n\\t            cfg = this.cfg.extend(cfg);\\n\\n\\t            // Convert string to CipherParams\\n\\t            ciphertext = this._parse(ciphertext, cfg.format);\\n\\n\\t            // Derive key and other params\\n\\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\\n\\n\\t            // Add IV to config\\n\\t            cfg.iv = derivedParams.iv;\\n\\n\\t            // Decrypt\\n\\t            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);\\n\\n\\t            return plaintext;\\n\\t        }\\n\\t    });\\n\\t}());\\n\\n\\n}));\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"root\",\"factory\",\"undef\",\"define\",\"amd\",\"CryptoJS\",\"lib\",\"Cipher\",\"undefined\",\"C_lib\",\"Base\",\"WordArray\",\"BufferedBlockAlgorithm\",\"Base64\",\"enc\",\"EvpKDF\",\"algo\",\"extend\",\"cfg\",\"createEncryptor\",\"key\",\"create\",\"_ENC_XFORM_MODE\",\"createDecryptor\",\"_DEC_XFORM_MODE\",\"init\",\"xformMode\",\"_xformMode\",\"_key\",\"reset\",\"call\",\"_doReset\",\"process\",\"dataUpdate\",\"_append\",\"_process\",\"finalize\",\"_doFinalize\",\"finalProcessedData\",\"keySize\",\"ivSize\",\"_createHelper\",\"cipher\",\"encrypt\",\"message\",\"PasswordBasedCipher\",\"SerializableCipher\",\"decrypt\",\"ciphertext\",\"StreamCipher\",\"finalProcessedBlocks\",\"blockSize\",\"C_mode\",\"mode\",\"BlockCipherMode\",\"iv\",\"Encryptor\",\"Decryptor\",\"_cipher\",\"_iv\",\"CBC\",\"xorBlock\",\"words\",\"offset\",\"block\",\"_prevBlock\",\"i\",\"processBlock\",\"encryptBlock\",\"slice\",\"thisBlock\",\"decryptBlock\",\"Pkcs7\",\"pad\",\"data\",\"blockSizeBytes\",\"nPaddingBytes\",\"sigBytes\",\"paddingWord\",\"paddingWords\",\"push\",\"padding\",\"concat\",\"unpad\",\"BlockCipher\",\"modeCreator\",\"_minBufferSize\",\"_mode\",\"__creator\",\"_doProcessBlock\",\"_data\",\"CipherParams\",\"cipherParams\",\"mixIn\",\"toString\",\"formatter\",\"stringify\",\"OpenSSLFormatter\",\"OpenSSL\",\"format\",\"salt\",\"wordArray\",\"parse\",\"openSSLStr\",\"ciphertextWords\",\"splice\",\"encryptor\",\"cipherCfg\",\"algorithm\",\"_parse\",\"plaintext\",\"OpenSSLKdf\",\"kdf\",\"execute\",\"password\",\"random\",\"compute\",\"derivedParams\"]\n}\n"]